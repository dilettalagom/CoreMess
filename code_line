WRITE ON CHAR-DEV
$ echo ciao > my_prova
$ cat my_prova
>ciao

//https://www.oreilly.com/library/view/linux-device-drivers/0596000081/ch03s04.html
void *private_data;
The open system call sets this pointer to NULL before calling the open method for the driver.
The driver is free to make its own use of the field or to ignore it.
The driver can use the field to point to allocated data,
but then must free memory in the release method before the file structure is destroyed by the kernel.
private_data is a useful resource for preserving state information across system calls and is used by most of our sample modules.

//http://www.makelinux.net/ldd3/chp-2-sect-8.shtml
S_IRUGO|S_IWUSR
Use S_IRUGO for a parameter that can be read by the world but cannot be changed;
S_IRUGO|S_IWUSR allows root to change the parameter. Note that if a parameter is changed by sysfs,
the value of that parameter as seen by your module changes, but your module is not notified in any other way.
You should probably not make module parameters writable, unless you are prepared to detect the change and react accordingly.

//https://www.kernel.org/doc/html/latest/core-api/kernel-api.html?highlight=register_chrdev_region
LIST_HEAD
-list_for_each_entry_safe_reverse(pos, n, head, member) :iterate backwards over list safe against removal
-list_first_entry

//https://tuxthink.blogspot.com/2011/01/creating-ioctl-command.html
IOCTL_BASE 'k' -> https://ufal.mff.cuni.cz/~jernej/2018/docs/predavanja06.pdf
The number should be unique across the system. Picking arbitrary number is a bad idea, because:
Two device nodes may have the same major number. An application could open more than one device and mix up the file
descriptors, thereby sending the right command to the wrong device. Sending wrong ioctl commands can have catastrophic
consequences, including damage to hardware. A unique magic number should be encoded into the commands

//https://stackoverflow.com/questions/29397364/copy-to-user-and-copy-from-user-for-basic-data-type
COPY_TO_USER
When a user passes data to kernel space, this data can be split on several pages, and these pages can be even in swapped out memory.
In these cases, you'll have to wait for the kernel to swap in the page and get access to the page where the data is in.
In the case of elementary data types (like int or pointers) it is also true that some architectures (notably x86 intel) don't force the user to align the data so even an integer can be split around a page border.
You can have access to the first part of you integer, but to wait for the second to get swapped in by the memory manager before the whole thing is accessed.
You can save some roundtrips by putting all user data in a structure whose pointer is passed to the kernel.
 You can copy_from_user it as a block and save accesses (and running into the risk of being blocked several times)
So, and as a conclusion, use the functions even for basic types, as there are plenty of them. Don't assume anything about where the user data can be when running in kernel mode.
You have access to it, but the kernel virtual addresses of user data have nothing to do with the virtual addresses seen in user mode.

//https://linux-kernel-labs.github.io/refs/heads/master/labs/deferred_work.html
struct delayed_work - it schedules a task to run after at least a given time interval
A delayed work uses a timer to run after the specified time interval. The calls with this type of work are similar to those for
struct work_struct, but has _delayed in the functions names.
WORK_QUEUES
Tasklets run in software interrupt context with the result that all tasklet code
must be atomic. Instead, workqueue functions run in the context of a special
kernel process; as a result, they have more flexibility. In particular, workqueue
functions can sleep.
-wait_event_hrtimeout
-wait_event_interruptible_hrtimeout

xml.com/ldd/chapter/book/ch05.html

//https://linux-kernel-labs.github.io/refs/heads/master/labs/deferred_work.html#:~:text=Deferred%20work%20is%20a%20class,the%20type%20of%20deferred%20work.
DELAYED_WORK
A delayed work uses a timer to run after the specified time interval. The calls with this type of work are similar to those for struct work_struct, but has _delayed in the functions names.

ALLOC_WORKQUEUE
https://www.kernel.org/doc/html/latest/core-api/workqueue.html
alloc_workqueue() allocates a wq. The original create_*workqueue() functions are deprecated and scheduled for removal.
alloc_workqueue() takes three arguments - @``name``, @flags and @max_active. @name is the name of the wq and also used as the name of the rescuer thread if there is one.
WQ_MEM_RECLAIM
All wq which might be used in the memory reclaim paths MUST have this flag set. The wq is guaranteed to have at least one execution context regardless of memory pressure.